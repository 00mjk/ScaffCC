/****************************************************************************************
* File: TriangleFindingProblem.quantum
*
* Author: Chen-Fu Chiang @ USherbrooke 
* 
* Implementation of the triangle finding algorithm specified in the 
* Quantum Computer Science Program @ Government Furnished Information document 
*
* Document date: June 20, 2011
* Document Version: 1.0.0
* Document Reversion number: 188
*
* Implementation date: 2012
*****************************************************************************************/
// Commonly used gates
gate H(qreg q[1]);
gate X(qreg q[1]);
gate Z(qreg q[1]);
gate S(qreg q[1]); 
gate T(qreg q[1]); 
gate Tdag(qreg q[1]); 
gate Sdag(qreg q[1]); 
gate CNOT(qreg target[1], qreg control[1]);



// Global variables 
/**************************************************************
#define n  15
#define N  32768	// N = 2 ^ n
#define r  9  		// r = (3/5)n
#define R  512		// R = 2 ^ r
#define RR1 130816	// RR1 = R(R-1)/2
#define rbar  6		// rbar = (2/5)n 
#define Rbar  64	// Rbar = 2^rbar
#define CTR  11		// CRT = 2*rbar - 1 
#define tm 64 		// Quantum walk iterations (floor of N/R)
#define tw 22		// Quantum walk step iterations (floor of sqrt(R))
#define tg  142 	// Grover iteration (pi/4)* (Sqrt(N))
#define tbarm 8		// R/Rbar
#define tbarw 22	// (floor of sqrt(R))
***************************************************************/


/**************************************************************
* 	Useful Modules
***************************************************************/ 
module Swap(qreg q1[1],qreg q2[1])
{
	CNOT(q2[0],q1[0]);
	CNOT(q1[0],q2[0]);
	CNOT(q2[0],q1[0]);
}

module ctrSwap(qreg q1[1],qreg q2[1], qreg q3[1])
{
	Toffoli(q2[0],q1[0], q3[0]);
	Toffoli(q1[0],q2[0], q3[0]);
	Toffoli(q2[0],q1[0], q3[0]);
}

module CR(qreg target[1], qreg control[1], double theta[1])   
{
	R(target[0], theta / 2.0);
	CNOT(target[0], control[0]);
	R(target[0], -1.0 * theta / 2.0);
	CNOT(target[0], control[0]);
}

module Toffoli(qreg target[1], qreg ctr2[1], qreg ctr1[1]) 
{
	H(target[0]); 
	CNOT(target[0],ctr2[0]); 
	Tdag(target[0]); 
	CNOT(target[0], ctr1[0]); 
	T(target[0]); 
	CNOT(target[0], ctr2[0]); 
	Tdag(target[0]); 
	CNOT(target[0], ctr1[0]); 
	Tdag(ctr2[0]); 
	T(target[0]); 
	CNOT(ctr2[0], ctr1[0]); 
	H(target[0]); 
	Tdag(ctr2[0]); 
	CNOT(ctr2[0], ctr1[0]); 
	T(ctr1[0]); 
	S(ctr2[0]); 
}

/***********************************************************
*	target[0] = OR(ctr2[0] , ctr1[0])
************************************************************/
module EvaluateOR(qreg target[1], qreg ctr2[1], qreg ctr1[1])
{
	X(ctr1[0]); 
	X(ctr2[0]); 
	Toffoli(target[0], ctr2[0], ctr1[0]); 
	X(target[0]); 
}

module InvEvaluateOR(qreg target[1], qreg ctr2[1], qreg ctr1[1])
{
	X(target[0]); 
	Toffoli(target[0], ctr2[0], ctr1[0]);
	X(ctr2[0]); 
	X(ctr1[0]); 
}

/******************************************************************
* Determine if a Node is a |00...0> and store the result in qubit
* Inverse of it must be run (after getting the final evaluation)
* to transform the input bits back
*******************************************************************/ 
module ZeroNodeTest(quNode w, qreg dum[n-1], int n)			
{
	int j = 0; 
	for(j = 0; j< n; j++)
	{
		X(w.reg[j]); 	
	}
	
	Toffoli(dum[0], w.reg[1], w.reg[0]); 
	for(j = 1; j < n-2; j++)
	{
		Toffoli(dum[j], dum[j-1], w.reg[j+1]); 	
	}
	
	Toffoli(dum[n-2], dum[n-3], w.reg[n-1]); 
}

module InvZeroNodeTest(quNode w, qreg dum[n-1], int n)			
{
	int j = 0; 
	Toffoli(dum[n-2], dum[n-3], w.reg[n-1]); 
	
	for(j = n-3; j > -1; j--)
	{
		Toffoli(dum[j], dum[j-1], w.reg[j+1]); 	
	}
	
	Toffoli(dum[0], w.reg[1], w.reg[1]);
	
	for(j = 0; j< n; j++)
	{
		X(w.reg[j]); 	
	}
}

/***************************************************************************
* Here we reuse the ancillae ctrbit[14] to see if input input[k] is all 0s Reg
****************************************************************************/
module ZeroRegTest(qreg input[k], qreg dum[n-1], int k)			
{
	int j = 0; 
	for(j = 0; j< k; j++)
	{
		X(input[j]); 	
	}
	
	Toffoli(dum[0], input[1], input[0]); 
	for(j = 1; j < k-2; j++)
	{
		Toffoli(dum[j], dum[j-1], input[j+1]); 	
	}
	
	Toffoli(dum[k-2], dum[k-3], input[k-1]); 
}


module InvZeroRegTest(qreg input[k], qreg dum[n-1], int k)			
{
	int j = 0; 
	Toffoli(dum[k-2], dum[k-3], input[k-1]); 
	
	for(j = k-3; j > -1; j--)
	{
		Toffoli(dum[j], dum[j-1], input[j+1]); 	
	}
	
	Toffoli(dum[0], input[1], input[0]);
	
	for(j = 0; j< k; j++)
	{
		X(input[j]); 	
	}
}

/******************************************************************************
*  Here we reuse the ancillae ctrbit[14] to see if input is an all 1s Register
*******************************************************************************/
module OneRegTest(qreg input[k], qreg dum[n-1], qreg ctrNode[1], int k)			
{
	int j = 0; 
	
	Toffoli(dum[0], input[1], input[0]); 
	for(j = 1; j < k-2; j++)
	{
		Toffoli(dum[j], dum[j-1], input[j+1]); 	
	}
	
	Toffoli(dum[k-2], dum[k-3], input[k-1]); 
	
	CNOT(qreg ctrNode[1], dum[k-2]); 
}

module InvOneRegTest(qreg input[k], qreg dum[n-1], qreg ctrNode[1], int k)			
{
	int j = 0; 
	
	CNOT(qreg ctrNode[1], dum[k-2]); 
	
	Toffoli(dum[k-2], dum[k-3], input[k-1]); 
	
	for(j = k-3; j > -1; j--)
	{
		Toffoli(dum[j], dum[j-1], input[j+1]); 	
	}
	
	Toffoli(dum[0], input[1], input[0]);
}
/***********************************************
Evaluate the qubit value in terms of boolean
************************************************/
boolean module evaluateToBool(qreg reg[1])
{
	int ret = 0; 
	qreg dreg[1]; 
	
	CNOT(dreg[0], reg[0]); 
	measX(dreg[0], ret); 
	
	if(ret == 1)
		return true; 
		
	else
		return false; 
}
 
// Replaced by CompareIJ
/***********************************************
* Convert a r-bit qreg into integer presentation
************************************************/
int module quIntrToInt(qreg ireg[r], greq treg[r], dum[n-1])
{
	int ret = 0;
	int i = 0; 
	int j = 0; 
	
	for(i = 0; i < r ; i++)
	{
		if(evaluateToBool(reg[i]))
			j = 1; 
		else
			j = 0; 
			
		ret += j*pow(2,i); 
	}
	
	return ret; 
}

//Replaced by CompareIJrbar 
/***********************************************************
* Convert a 6-bit (rbar-bit) qreg into integer presentation
***********************************************************/
int module quInt6ToInt(qreg reg[6])
{
	int ret = 0;
	int i = 0; 
	int j = 0; 
	
	for(i = 0; i < 6 ; i++)
	{
		if(evaluateToBool(reg[i]))
			j = 1; 
		else
			j = 0; 
			
		ret += j*pow(2,i); 
	}
	
	return ret; 
}

/***********************************************************
* CompareIJ
* Para: quantum integer ireg, array index idxIJ (note here
* the idxIJ is an element of type quIntr, not an array of quIntr)
* ctrbit2
* Calls CompareIndexr to get the bitwise comparision of indices
* Calls OneRegTest to see if the bitwise comparison is all 1
* Because of this module is called by many elementary comparison
* operations, such as FetchT, FetchE, and etc. Hence, 
* we need to pass those parameters (idxIJ, ctrbit2, ctrbit, ctrNode)
* to many modules, even these 4 parameters are not specified in the
* GFI document 
***********************************************************/
module CompareIJ(qreg ireg[r], quIntr idxIJ, qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1])
{
	CompareIndexr(ireg, idxIJ, ctrbit2);  
	OneRegTest(ctrbit2, ctrbit, ctrNode, r);  
}

module InvCompareIJ(qreg ireg[r], quIntr idxIJ, qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1])
{
 	InvOneRegTest(ctrbit2, ctrbit, ctrNode, r);  
 	InvCompareIndexr(ireg, idxIJ, ctrbit2);  
}

/***********************************************************
* CompareIndexr
* See if two indices of size r are the same
* Para: ireg and treg are the two indices we are comparing
*		dum is the global ctrbit2[14] we can reuse 
*		each bit comparison is written to dum array 
***********************************************************/
module CompareIndexr(qreg ireg[r], quIntr treg, qreg dum[n-1])
{
	int i = 0; 
	
	for (i = 0; i < r; i++)
	{
		CNOT(treg.reg[i], ireg[i]); 
		CNOT(dum[i], treg.reg[i]); 
	}	
}

/***********************************************************
* InvCompareIndexr
* Inverse of CompareIndexr
* Para: ireg and treg are the two indices we are comparing
*		dum is the global ctrbit2[14] we can reuse and it 
*		records the bit-wise comparison
***********************************************************/
module InvCompareIndexr(qreg ireg[r], quIntr treg, qreg dum[n-1])
{
	
	int i = 0; 
	
	for (i = r-1; i > -1; i--)
	{
	 	CNOT(dum[i], treg.reg[i]);
		CNOT(treg.reg[i], ireg[i]); 
	}	
}

/***********************************************************
* CompareIJrbar
* Similar to CompareIJ but the index is now 
* (note here the idxIJ is an element of type quIntr, not an array of quIntr)
* of length rbar
***********************************************************/
module CompareIJrbar(qreg ireg[rbar], quIntr idxIJ, qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1])
{
	CompareIndexrbar(ireg, idxIJ, ctrbit2);  
	OneRegTest(ctrbit2, ctrbit, ctrNode, rbar);  
}

module InvCompareIJrbar(qreg ireg[rbar], quIntr idxIJ, qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1])
{
 	InvOneRegTest(ctrbit2, ctrbit, ctrNode, rbar);  
 	InvCompareIndexrbar(ireg, idxIJ, ctrbit2);  
}

/***********************************************************
* CompareIndexrbar
* Similar to CompareIndexr but the length is rbar
***********************************************************/
module CompareIndexrbar(qreg ireg[rbar], quIntr treg, qreg dum[n-1])
{
	int i = 0; 
	
	for (i = 0; i < rbar; i++)
	{
		CNOT(treg.reg[i], ireg[i]); 
		CNOT(dum[i], treg.reg[i]); 
	}	
}

/***********************************************************
* InvCompareIndexrbar
* Similar to InvCompareIndexrbar but the length is rbar
***********************************************************/
module InvCompareIndexrbar(qreg ireg[rbar], quIntr treg, qreg dum[n-1])
{
	
	int i = 0; 
	
	for (i = rbar-1; i > -1 ; i--)
	{
	 	CNOT(dum[i], treg.reg[i]);
		CNOT(treg.reg[i], ireg[i]); 
	}	
}


/***********************************************************
* ctrCTRincr
* Increment the GC.cTri by 1; considering element at 
* location 0 is the least significant bit. So we are
* starting from the most significant bit (use of toffoli being
* controlled by less significant bits), repeat this process
* till we do CNOT on the 2nd least significant bit (controlled by 
* the least significant bit) and then finally do a CNOT operation
* on the least significant bit controlled by the ctrbit. The reverse of 
* this operation would be a decrement. 
* Assuming that overflow case will not occur 
***********************************************************/
module ctrCTRincr(qreg cTri[2*rbar-1], qreg ctrQ[1], qreg ctrbit2[n-1], qreg ctrNode[1])
{
	int i = 0; 
	int j = 0; 
	
	/***************************************************************************
	* we do 2*rbar -1 but actually we only need to run to 2*rbar-2
	* the value of if the first t elements (0 till t-1) in cTri are all 1s is stored at
	* ctrbit2[t-2] where t should be greater than 1
	*****************************************************************************/

	OneRegTest(cTri, ctrbit2, ctrNode[0], 2*rbar-1); 	
	for(i = 2*rbar - 2; i > 1; i--)
	{
		CNOT(cTri[i], ctrbit2[i-2]); 
	}
	
	ZERO(ctrNode[0]); 
	for(j = 0; j< n-1; j++)
	{
		ZERO(ctrbit2[j]; 
	}
	CNOT(cTri[1], cTri[0]); 
	CNOT(cTri[0], ctrQ[0]); 
}

/***********************************************************
* ctrCTRdecr
* decrement the GC.cTri by 1; similar to increment case but
* we have to test the all 0s case, instead of all 1s case.
* Assuming that overflow case will not occur 
***********************************************************/
module ctrCTRdecr(qreg cTri[2*rbar-1], qreg ctrQ[1], qreg ctrbit2[n-1], qreg ctrNode[1])
{
	int i = 0; 
	int j = 0; 
	
	ZeroRegTest(cTri, ctrbit2, ctrNode[0], 2*rbar-1); 	
	
	for(i = 2; i < 2*rbar-1; i++)
	{
		/************************************************************************
		* have to do so because in the Zero test we perform X operation
		* and since we are not going to do the inverse of that test, we need to 
		* make sure elements in cTri are restored to it original values
		* we do not restore element at 0 and 1 now because we will do that later
		**************************************************************************/
		X(cTri[i]); 
	}
	
	for(i = 2*rbar - 2; i > 1; i--)
	{
		CNOT(cTri[i], ctrbit2[i-2]); 
	}
	
	ZERO(ctrNode[0]); 
	for(j = 0; j< n-1; j++)
	{
		ZERO(ctrbit2[j]; 
	}
	
	// restoring element at location 1
	X(cTri[1]); 
	CNOT(cTri[1], cTri[0]);
	
	// restoring element at location 0 
	X(cTri[0]); 
	CNOT(cTri[0], ctrQ[0]); 
}

/***********************************************
* Measure a node
************************************************/
module nodeMeasure(quNode w, int ret[n])
{
	int i;
	
	for(i = 0; i < n ; i++)
	{
		measX(w.reg[i], ret[i]); 
	}
}
 

/***********************************************
* Measure array of nodes and store the value
************************************************/
module TMeasure(quNode T[R], int res[R][n])
{
	int i;
	int j; 
	
	for(i = 0; i < R ; i++)
	{
		for(j = 0; j< n; j++)
		{
			measX(T[i].reg[j], res[i][j]); 
		}
	}
}
 

/*****************************************************
* Measure array of edge connection and store the value
******************************************************/
module EMeasure(qreg E[RR1], int fin[RR1])
{
	int i;
	
	for(i = 0; i < RR1 ; i++)
	{
			measX(E[i], fin[i]); 
	}
}
 

/**************************************************************
*	Data Structures 
**************************************************************/
struct quNode  
{ qreg reg[n]; 
  qreg phase[1]; 
};

struct GCQWRegs 
{
	// extra 1 bit (or qIntr) is needed for recording the phases
	qIntr tau[Rbar+1]; 
	qreg  sigma[r+1]; 
	qreg  iota[rbar]; 
	qreg  Ew[Rbar]; 
	qreg  cTri[2*rbar-1];	
	//qubit holding test results for the triangle in T 	
	qreg  triTestT[1];   		 
	//qubit holding test results for the triangle in T and w
	qreg  triTestw[1]; 			 
}; 
 
struct quInt   
{ qreg reg[31];
};
 
struct quIntr   
{ qreg reg[r];	  
};
 

/********************************************************************
*	Algorithm 1: QWTFP
*	Para: n: 2^n is the number of nodes in the graph 
*	      r: 2^r is the size of R-Tuples in the Hamming graph H(V,R)
*	Return:  Yes/No if the graph has a triangle   
********************************************************************/
int module QWTFP(int n, int r)
{
	int j = 0; 
	int k = 0; 
	int l = 0; 
	
	// Required quantum registers (the initial circuit input)
	// T: 512 * 16; v:15; E:130816; w:16 (1 extra bit for phase); 
	// testTEdge: 1; test: 1; GC: 678
	// Hence, the total initial quantum circuit input is approx 145000
	
	quNode T[R];			 
	qreg i[r]; 
	quNode v; 				 
	qreq E[RR1];
	quNode w; 
	qreg testTEdge[1]; 
	qreg test[1];
	qreg TEPhase[1]; 
	qreg ctrbit[14]; 
	qreg ctrbit2[14];
	qreg ctrNode[1]; 
	
	/*******************************************************************
	* used for index matching 
	* each element inside idxIJ (let say idxIJ[k]) is physically wired
	* close to the quNode T[k] such that when and index i is given, 
	* we compare i and idxIJ[k] for k = 0 ... 511 until we find a match
	* Once match is found, we continue with the corresponding T[k] to 
	* proceed with corresonding operation.
	* The initialization of this index, in physical implementation, is not 
	* needed because we can just hardwire the NOT gates (to turn 0 to 1)
	* to let idxIJ[k] to represent the number k (in binary presentation).
	* However, in simulation, we need to do the initialization. 
	***********************************************************************/
	quIntr idxIJ[R]; 
	
	// used for initializing idxIJ from 0 to 511 
	int bin[r]; 
	
	// the quotient 
	int quo = 0; 
	
	// Graph Collision Register
	GCQWRegs GC; 
	
	int testTMeasure = 0; 
	
	int ret[n]; 
	int res[R][n]; 
	int fin[RR1]; 
	
	ZERO(test);					
	ZERO(testTEdge); 
	
	
	for( j = 0; j < R; j++)
	{	
		for(l = 0; l < r; l++)
			bin[l] = 0; 
			
					
		for(k = 0; k < n; k++)
		{
			INITIALIZE(T[j].reg[k]); 
		}
		
		
		// get the binary presentation of the number j 
		quo = j; 
		
		for(l = 0; l < r; l++)
		{
			bin[l] = quo%2; 
			quo = quo/2; 	
			if(quo==0)
			{break;}
		}
		
		/**************************************************************************
		* Initialize idxIJ[j]; this loop could have been merged with previous loop 
		*  used for the binary presentation but for readability, we separate them. 
		***************************************************************************/ 
		for(l = 0; l < r; l++)
		{
			if(bin[l] == 1)
				X((idxIJ[j]).reg[l]); 
		}
	}
	
	for(j=0; j<r; j++)
	{
		INITIALIZE(i.reg[j]);
	} 		
	
	for(j = 0; j<n; j++)
	{
		INITIALIZE(v.reg[j]); 
	}
	
	// To generate the (|0>-|1>)/sqrt(2) state for recording phase later
	H(X(v.phase[0])); 
	
	for(j = 0; j < n; j++)
	{
		ZERO(w.reg[j]); 
	}
	
	// To generate the (|0>-|1>)/sqrt(2) state for recording phase later
	H(X(w.phase[0])); 
	
	for(j = 0; j < Rbar; j++)
	{
		for(k = 0; k < r; k++)
		{
			ZERO((GC.tau[j]).reg[k]); 
		}
	}
	
	// To generate the (|0>-|1>)/sqrt(2) state for recording phase later
	// The phase is encoded at the last (extra qIntr) element's (r qubits) first qubit
	H(X((GC.tau[Rbar]).reg[0])); 
	
	for(j = 0; j < rbar; j++)
	{ ZERO(GC.iota[j]);}
	
	for(j = 0; j < r; j++) 
	{ ZERO(GC.sigma[j]);}
	
	// To generate the (|0>-|1>)/sqrt(2) state for recording phase later
	H(X(GC.sigma[r])); 
	
	
	for(j = 0; j< Rbar; j++)
	{ZERO(GC.Ew[j]);} 
	
	for(j = 0; j < 2*rbar-1; j++)
		{ZERO(GC.cTri[j]);}
		
	ZERO(GC.triTestT);
	ZERO(GC.triTestTw); 
	
	// Set up E with the edget information for T
	SETUP(E,T,R); 
	
	// Quantum Walk on the Hamming Graph
	for(j = 0; j < tm; j++)
	{
		// Test T for triangle edges
		TestTriangleEdges(T,E,w, n, r, GC, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
		
		EvaluateOR(ctrbit[0], GC.triTestT, GC.triTestTw); 
		
		// Phase flip for TE 
		CNOT(TEPhase[0], ctrbit[0]); 
		InvEvaluateOR(ctrbit[0], GC.triTestT, GC.triTestTw); 
		
		//TODO: Assume the inverse function will be present when provided the original circuit 
		InvTestTriangleEdges(T,E,w,n,r,GC,  idxIJ, ctrbit2, ctrbit, ctrNode[0]); 			
		
		// Quantum Walk on H(V,R)
		for(k = 0; k < tw; k++)
		{
			QWSH(T,i, v, E, n, r, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
		}
	}
	
	
	// Final Check for triangle edges in T
	TestTriangleEdges(T,E,w,n,r,GC); 
	
	
	// if GC.triTestTw is 1, then testTMeasure should be set to 1
	EvaluateOR(ctrbit[0], GC.triTestT, GC.triTestTw); 
	ctrONE(testTEdge[0], ctrbit[0]); 
	InvEvaluateOR(ctrbit[0], GC.triTestT, GC.triTestTw); 
	measX(testTEdge, testTMeasure); 
	
	// Get the triangle information if the testTMeasure is 1 (there is a triangle)
	if(testTMeasure==1)
	{
		//meansure T, E and w  
		nodeMeasure(w, ret); 
		TMeasure(T, res); 
		EMeasure(E, fin); 
	}
	
	// return YES/NO ; if yes, then we need to check ret, res and fin
	return testTMeasure; 
}
 

/**************************************************************
* 	Algorithm 2-0: ONE
*	Initializes the qubits in a register to 1
*	Para: qreg reg[] of size 1 
***************************************************************/ 
module ONE(qreg reg[1])           
{
	qreg dreg[1]; 
	CNOT(dreg[0], reg[0]); 
	X(dreg[0]);
	CNOT(reg[0], dreg[0]);   
}

/**************************************************************
* 	Algorithm 2-1: ctrONE
*	Initializes the qubits in a register to 1
*	Para: qreg reg[] of size 1 
***************************************************************/ 
module ctrONE(qreg reg[1], qreg test[1])           
{
	qreg dreg[1]; 
	Toffoli(dreg[0], reg[0], test[0]); 
	CNOT(dreg[0], test[0]);
	Toffoli(reg[0], dreg[0], test[0]);   
}
 

/**************************************************************
* 	Algorithm 2: ZERO
*	Initializes the qubits in a register to 0
*	Para: qreg reg[] of size n 
***************************************************************/ 
module ZERO(qreg reg[1])
{
	qreg dreg[1];  		
	CNOT(dreg[0], reg[0]); 
	CNOT(reg[0], dreg[0]); 
}
 

/***********************************************************************
* 	Algorithm 3: INITIALIZE
*	Sets each qubit in the n-qubit register reg to 0 and
*	then calls the Hadamard gate to place reg into superpostion
*	Para: qreg reg[] of size 1 
*	Comment: Along with a loop, we can use this module for 
*	to perform INITIALIZE work on input register of size greater than 1. 
***********************************************************************/ 
 
 module INITIALIZE(qreg reg[1]) 
{
	ZERO(reg[0]);  
	H(reg[0]); 
}
 

/**************************************************************
* 	Algorithm 4: HADAMARD
*	Applies the Hadamard primitive to each qubit in the register
*	Para: qreg reg[] of size n 
* 	Comment: This modules applies the Hadamard primitive to each 
* 	qubit in the register, that is a combination of for loop 
*	of size n and n uses of Hadamard primitive. Whenever we 
*	encounter the invocation of this module, we directly
*	use a combination of for loop along with the Hadamard 
* 	primitive (H) to perform such a task. 
***************************************************************/ 



/**************************************************************
* 	Algorithm 5: SETUP
*	Para: E a (R(R-1)/2)-qubit reg
*         T a quNode[R]register: 
*	      T[j] a quNote for j = 0,1,..., R-1 
***************************************************************/ 
module SETUP(qreg E[RR1], quNode T[R], int R)					
{
	int j = 0; 
	int k = 0; 
	int jk = 0; 
	int l = 0; 
	
	for(l = 0; l < RR1; l++)
	{
		ZERO(E[l]); 
	}
	
	
	//Comment: This step seems redundant since previous step already ZERO all elements
	for(j = 0; j < R-1; j++)
	{	
		for(k=j+1; k < R; k++)
		{
			jk = ((k*(k-1))/2) + j; 
			ZERO(E[jk]); 
			
			// Note: In Oracle implementation, the oracle takes 3 parameters; 
			// hence, we have 3 parameters here. 
			EdgeORACLE(T[j], T[k], E[jk]); 	 
		}
	}
}
 

/**************************************************************
* 	Algorithm 6
*	Para: T an array of quNodes
*	      i a quInt register  
*	      v a quNode register (that is n qubits) 
*	      E a (R(R-1)/2)-qubit register 
*		  quIntr idxIJ[R] 
*		  qreg ctrbit2[n-1]
*		  qreg ctrbit[n-1] 
*	      qreg ctrNode[1]	  
***************************************************************/ 
 
module QWSH(quNode T[R], qreg i[r], quNode v, qreg E[RR1], int n, int r, quIntr idxIJ[R],qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1]) 
{
	quNode Td; 
	qreg Ed[R]; 
	int i; 
	
	for(i = 0; i<n; i++)
	{
		ZERO(Td[i]);
		ZERO(Ed[i]); 
	}
	
	//Diffuse on i and v registers
	DIFFUSEVI(v, i, n+r); 	
	
	FetchT(i, T, Td, r, n, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	
	FetchStoreE(i, E,Ed, r, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	
	UPDATE(T, Td, Ed, r); 
	
	StoreT(i, T, Td, r, n, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	
	SWAP(Td, v, n); 
				
	StoreT(i, T, Td, r, n, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	
	UPDATE(T, Td, Ed, r); 
	
	// Note: the GFI has an extra R parameter that is a mistake as 
	// FetchStoreE only takes 4 parameters and R = 2^r
	FetchStoreE(i, E, Ed, r, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	
	// Note: the GFI has an extra R parameter that is a mistake 
	// as FetchT only takes 5 parameters and R = 2^r
	FetchT(i, T, Td, r, n, idxIJ, ctrbit2, ctrbit, ctrNode[0]);  
}
 

/**************************************************************
* 	Algorithm 7
*	Para: w a quNode
*	      n an given number [size of w]
***************************************************************/  
module DIFFUSENode(quNode w, int n)
{
	int j = 0; 
	for(j = 0; j < n; j++)
	{
		H(w.reg[j]);
	}	
		// get a minus sign for the state
		X(w.phase[0]); 
			
		//now need to reset the minus sign if the stat is |000...0>
		ZeroNodeTest(w, ctrbit, n); 
		CNOT(w.phase[0], ctrbit[n-2]); 
		InvZeroNodeTest(w, ctrbit, n); 
	
	for(j = 0; j < n; j++)
	{
		H(w.reg[j]);
	}
}
 

/**************************************************************
* 	Algorithm 7-1
*	Para: alpha: quNode of size n
*		  beta: quantum registers of size r
*		  toal: sum of n and r
***************************************************************/ 
// perform Diffuse on two registers of size n (thi is quNode) and r, respectively
module DIFFUSEVI(quNode alpha, qreg beta[r], int tol)
{
	int j = 0; 
	int i = 0; 
	
	// since quNode is always of size n 
	for(j = 0; j < n; j++)
	{
		H(alpha.reg[j]);
	}
	
	for(i = 0; i < r; i++)
	{
			H(beta[i]);
	}
	
	X(alpha.phase[0]);
	
	
	ZeroNodeTest(alpha, ctrbit, n); 
	// ctrbit2 is also of size n-1, hence, we have extra n-r = 6 bits left after ZeroRegTest
	ZeroRegTest(beta, ctrbit2, r); 
	Toffoli(ctrbit2[r-1], ctrbit2[r-2], ctrbit[n-2]); 
	CNOT(alpha.phase[0], ctrbit2[r-1]); 
	
	//uncompute 
	Toffoli(ctrbit2[r-1], ctrbit2[r-2], ctrbit[n-2]);
	InvZeroRegTest(beta, ctrbit2, r); 
	InvZeroNodeTest(alpha, ctrbit, n); 
	

	for(j = 0; j < n; j++)
	{
		H(alpha[j]);
	}
	
	for(i = 0; i < r; i++)
	{
		H(beta[i]);
	}
}
 

/********************************************************************
* 	Algorithm 7-2
*	Para: ta, ma:  are quantum registers(iota and sigma) of GCQWRegs
*		  tol: sum of sizes of iota and sigma
*********************************************************************/ 
 
// perform Diffuse on two registers of size rbar and r, respectively
module DIFFUSEGC(qreg ta[rbar], qreg ma[r+1], int tol)
{
	int i  = 0; 
	int j = 0;
	for(i = 0; i < rbar; i++)
	{
		H(ta[i]);
	}
	
	for(j = 0; j < r; j++)
	{
		H(ma[j]);
	}	
	
	// get minus sign for all states
	X(GC.sigma[r]);	
	
	// remove minus sign for |00..0>
	ZeroRegTest(ta, ctrbit, rbar); 
	// ctrbit2 is also of size n-1, hence, we have extra n-r = 6 bits left after ZeroRegTest
	ZeroRegTest(ma, ctrbit2, r); 
	Toffoli(ctrbit2[r-1], ctrbit2[r-2], ctrbit[rbar-2]); 
	CNOT(GC.sigma[r], ctrbit2[r-1]); 
	
	//uncompute 
	Toffoli(ctrbit2[r-1], ctrbit2[r-2], ctrbit[rbar-2]); 
	InvZeroRegTest(ma, ctrbit2, r);
	InvZeroRegTest(ta, ctrbit, rbar); 

	for(i = 0; i < rbar; i++)
	{
		H(ta[i]);
	}
	 
	for(j = 0; j < r; j++)
	{
		H(ma[j]);
	}
}
 

/**************************************************************
* 	Algorithm 8
*	Para: I	quIntr 
*	      T an array of R quNodes
*	      Td a quNode register (that is n qubits) 
*	      r integer (given)
*         n integer (given)	
*		  quIntr idxIJ[R] 
*		  qreg ctrbit2[n-1]
*		  qreg ctrbit[n-1] 
*	      qreg ctrNode[1]
***************************************************************/ 
module FetchT(qreg I[r], quNode T[R], quNode Td, int r, int n, quIntr idxIJ[R], qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1])
{
	int j = 0;
	int k = 0;
	
	// depreciated
	// int i = quIntrToInt(I);  
	
	for(j = 0; j < R; j++)  
	{	
		CompareIJ(I, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 
		   
		    for(k = 0; k < n; k++)
			{
				Toffoli(Td.reg[k], T[j].reg[k], ctrNode[0]); 
			}
		InvCompareIJ(I, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 				     			  
		
	}
}
 
/**************************************************************
* 	Algorithm 8-1
*	Para: I	quInt 
*	      T an array of R qubits
*	      Td an array of Rbar qubits 
*	      r integer (given)
*         b integer (in this case it is 1)	
*		  quIntr idxIJ[R] 
*		  qreg ctrbit2[n-1]
*		  qreg ctrbit[n-1] 
*	      qreg ctrNode[1]
***************************************************************/ 
 
module FetchTr1(qreg I[r], qreg T[R], qreg Td[1], int r, int b, quIntr idxIJ[R], qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1])
{
	int j = 0;
	int k = 0;
	
	// depreciated
	// int i = quIntrToInt(I);  
	
	for(j = 0; j < R; j++)  
	{	
		CompareIJ(I, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 
		for(k = 0; k < b; k++)
			{
				// in this case, k is always 0
				Toffoli(Td[k], T[j], ctrNode[0]); 
			}
		InvCompareIJ(I, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 				     			  
		
	}
}
 

/**************************************************************
* 	Algorithm 8-2
*	Para: iota	quInt 
*	      tau an array of R qubits
*	      Td an array of Rbar qubits 
*	      rbar integer (given)
*         r integer (given)	
*		  quIntr idxIJ[R]  
*		  qreg ctrbit2[n-1]
*		  qreg ctrbit[n-1] 
*	      qreg ctrNode[1]
***************************************************************/ 
module FetchTrbarr(qreg iota[rbar], quIntr tau[Rbar], qreg Td[r], int rbar, int r, quIntr idxIJ[R], qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1])
{
	int j = 0;
	int k = 0;
	// depreciated
	// int i = quInt6ToInt(iota);  
	
	for(j = 0; j < Rbar; j++)  
	{	
		CompareIJrbar(iota, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 
			for(k = 0; k < r; k++)
			{
				// in this case, k is always 0
				Toffoli(Td[k], tau[j].reg[k], ctrNode[0]);  
			}				     			  
		InvCompareIJrbar(iota, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 
	}
}
 


/**************************************************************
* 	Algorithm 9
*	Para: i	quInt 
*	      T an array of R quNodes
*	      Td a quNode register (that is n qubits) 
*	      r integer (given)
*	      n integer	(given)
*		  quIntr idxIJ[R]  
*		  qreg ctrbit2[n-1]
*		  qreg ctrbit[n-1] 
*	      qreg ctrNode[1]
***************************************************************/ 
module StoreT(qreg I[r], quNode T[R], quNode Td, int r, int n, quIntr idxIJ[R],qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1]) 
{
	int j = 0;
	int k = 0;
	
	// depreciated
	// int i = quIntrToInt(I); 
	 
	for(j = 0; j < R; j++) 
	{	
		CompareIJ(I, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 
			for(k = 0; k < n; k++)
			{
				Toffoli(T[j].reg[k], Td.reg[k], ctrNode[0]); 
			}
		InvCompareIJ(I, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 
		
	}
}

/**************************************************************
* 	Algorithm 9-1
*	Para: i	quInt6 
*	      T an array of Rbar quIntr
*	      Td  r qubits
*	      rbar integer (given)
*	      r integer	(given )
*		  quIntr idxIJ[R]  
*		  qreg ctrbit2[n-1]
*		  qreg ctrbit[n-1] 
*	      qreg ctrNode[1]
***************************************************************/ 
module StoreTrbarr(qreg I[rbar], quIntr T[Rbar], qreq Td[r], int rbar, int r, quIntr idxIJ[R],qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1]) 
{
	int j = 0;
	int k = 0;
	// depreciated
	// int i = quIntr6ToInt(I); 
	 
	for(j = 0; j < Rbar; j++) 
	{	
		CompareIJrbar(I, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 
			for(k = 0; k < r; k++)
			{
				Toffoli(T[j].reg[k], Td[k], ctrNode[0]); 
			}
		InvCompareIJrbar(I, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 
	}
}
 

/**************************************************************
* 	Algorithm 10
*	Para: i	quInt 
*	      T an array of R quNodes
*	      Td a quNode register (that is n qubits) 
*	      rbar integer (given) 
*	      b integer	(given) [cannot use the global variable n]
*		  quIntr idxIJ[R]  
*		  qreg ctrbit2[n-1]
*		  qreg ctrbit[n-1] 
*	      qreg ctrNode[1]
*	Comment: As seen in later function calls, the parameter b
*	could be of values other than n or r. 
***************************************************************/ 
module FetchStoreT(qreg I[rbar], qreg T[Rbar], qreg Td[1], int rbar, int b,  quIntr idxIJ[R],qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1])  
{
	int j = 0;
	int k = 0; 
	// depreciated 
	// and typo in the method 	int i = quIntr6ToInt(I); 
	
	for(j = 0; j < Rbar; j++) 
	{	
		CompareIJrbar(I, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 
			for(k = 0; k < b; k++)
			{
				// Here it is only one bit, hence, do not use SWAP but Swap
				// Throughout the whole program, when this module is summoned, the parameter b is always 1
				// Since b is always 1, k is always 0
				ctrSwap(T[j], Td[k], ctrNode[0]);
			}
		InvCompareIJrbar(I, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 
	}
}
 

/**************************************************************
* 	Algorithm 11
*	Para: i	quInt 
*	      E qreg[] of size (R(R-1)/2)
*	      Ed qreg[] of size R
*	      a integer (given)
*		  quIntr idxIJ[R]  
*		  qreg ctrbit2[n-1]
*		  qreg ctrbit[n-1] 
*	      qreg ctrNode[1]
***************************************************************/ 
module FetchE(qreg I[r], qreg E[RR1], qreg Ed[R], int r, quIntr idxIJ[R], qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1]) 
{
	int j = 0;
	
	// depreciated
	// int i = quIntrToInt(I); 
	int k = 0;
	int kj = 0; 
	int jk = 0; 
	 
	for(j = 0; j < R; j++) 		
	{	
		CompareIJ(I, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 
			for(k = 0; k < j; k++)
			{
				kj = ((j*(j-1))/2) + k; 	
				Toffoli(Ed[k], E[kj], ctrNode[0]); 
			}

			for(k = j+1; k < R ; k++)		
			{
				jk = ((k*(k-1))/2) + j; 
				Toffoli(Ed[k], E[jk], ctrNode[0]); 		
			}
		InvCompareIJ(I, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 
	}
}
 


/**************************************************************
* 	Algorithm 12
*	Para: I	quInt of size r
*	      E qreg[] of size (R(R-1)/2)
*	      Ed qreg[] of size R
*	      a integer (given) 
*		  quIntr idxIJ[R]  
*		  qreg ctrbit2[n-1]
*		  qreg ctrbit[n-1] 
*	      qreg ctrNode[1]
***************************************************************/ 
module FetchStoreE(qreg I[r], qreg E[RR1], qreg Ed[R], int r,  quIntr idxIJ[R], qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1]) 
{
	int j = 0;
	int k = 0;
	int kj = 0; 
	int jk = 0;  
	// depreciated
	//int i = quIntrToInt(I); 
	
	for(j = 0; j < R; j++) 		 
	{	
		CompareIJ(I, idxIJ[j], ctrbit2, ctrbit, ctrNode); 
			for(k = 0; k < j; k++)
			{
				kj = ((j*(j-1))/2) + k; 
				//Note: only 1 bit change, should be Swap, not SWAP(given in GFI document)
				// depreciated; because of ctrNode; Swap(E[kj], Ed[k]); 
				ctrSwap(E[kj], Ed[k], ctrNode[0]); 	 
			}

			for(k = j+1; k < R ; k++)		
			{
				// Maybe we can reuse the variable kj without using variable jk
				jk = ((k*(k-1))/2) + j;
				//Note: only 1 bit change, should be Swap, not SWAP(given in GFI document) 
				// depreciated; because of ctrNode; Swap(E[jk], Ed[k]); 	
				ctrSwap(E[jk], Ed[k], ctrNode[0]); 	
			}								
		InvCompareIJ(I, idxIJ[j], ctrbit2, ctrbit, ctrNode[0]); 
	}
}
 

/**************************************************************
* 	Algorithm 13
*	Para: T quNode[R] register 
*	      Td a quNode: qreg[] of size n
*	      Ed qreg[] of size R
*	      r integer (given)
***************************************************************/ 
 
module UPDATE(quNode T[R], quNode Td, qreg Ed[R], int r ) 
{	
	int j = 0;
	qreg tmp[1]; 
	
	for(j = 0; j < R; j++) 		
	{	
		EdgeORACLE(T[j], Td, tmp[0]); 
		Swap(Ed[j], tmp[0]); 
	}
}
 

/**************************************************************
* 	Algorithm 14
*	Para: Td a quNode: qreg[] of size n
*	      v a quNode: qreg[] of size n
*	      n integer (given) [OK to use global variable]
***************************************************************/ 
 
module SWAP(quNode Td, quNode v, int n ) 
{
	int j = 0;
	for(j = 0; j < n-1; j++) 		
	{	
		// three CNOT is a simple bit-wise Swap
		CNOT(Td.reg[j], v.reg[j]); 			
		CNOT(v.reg[j], Td.reg[j]);	 		
		CNOT(Td.reg[j], v.reg[j]); 
	}
}
 

/****************************************************************************************
* 	Algorithm 15
*	Para: T: a quNode[R] register
*		  E: qreg[(R(R-1))/2]
*		  w: a quNode: qreg[] of size n
*		  n integer (given)
*		  r integer (given) [OK to use global r]
*		  GCQWRegs (Graph Collision Workspace Registers) 
*		  quIntr idxIJ[R]  
*		  qreg ctrbit2[n-1]
*		  qreg ctrbit[n-1] 
*	      qreg ctrNode[1]
*	Comment: triTestT set to 1 is T contains the triangle from G
*			 triTestTw set to 1 when w is a node of the triangle with the other edge in T 
*****************************************************************************************/ 
 
module TestTriangleEdges(quNode T[R], qreg E[RR1], quNode w, int n, int r, GCQWRegs GC, quIntr idxIJ[R],qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1]) 
{
	// set triTestT to 1 if T contains the triangle 
	TriangleTestT(E, n, r, GC.triTestT); 			
	
	
	// Grover with Graph collision 
	// Mistake in the GFI document; TriangleEdgeSearch function does not need 
	// triTestT parameter as it is embeded in GC register; here I removed that 
	// parameter from the code
	TriangleEdgeSearch(T,E,w,n,r,rbar, GC, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 		
 	
 	
 	// Marking T, w and copy that value
	// The data structure of GCQWRegs misses the field "iota" in statement of algorithm 15 	
 	TriangleTestTw(T,E,w, n,r, GC.triTestTw);   	
}
  
/**************************************************************
* 	Algorithm 16
*	Para: E: qreg[(R(R-1))/2]
*	      n integer (given)
*		  r integer (given) [OK to use the global r]
*		  test: qreg[1] 
***************************************************************/ 
module TriangleTestT(qreg E[RR1], int n, int r, qreg test[1]) 	 
{																	
	int i = 0; 
	int j = 0; 
	int k = 0;
	int ij = 0; 
	int ik = 0; 
	int jk = 0; 
		
	for(i=0; i < R; i ++) 		
	{
		for (j = i+1; j < R; j++)
		{
			ij = i + (j*(j-1))/2; 
				for (k = j+1; k < R; k++)
				{
					ik = i + (k*(k-1))/2; 
					jk = j + (k*(k-1))/2; 
					Toffoli(ctrbit[0], E[ij], E[ik]); 
					Toffoli(ctrbit[1], ctrbit[0], E[jk]); 
					EvaluateOR(ctrbit[2], ctrbit[1], test[0]); 
					CNOT(ctrbit[3], ctrbit[2]); 
					
					// uncompute 
					InvEvaluateOR(ctrbit[2], ctrbit[1], test[0]);
					Toffoli(ctrbit[1], ctrbit[0], E[jk]); 
					Toffoli(ctrbit[0], E[ij], E[ik]); 
					
					ctrONE(test[0], ctrbit[3]); 
					
					// need ancilla here
					ZERO(ctrbit[3]); 
				}
		}
	}	
}
 

/**************************************************************
* 	Algorithm 17
*	Para: T: a quNode[R] register
*		  E: qreg[(R(R-1))/2]
*		  w: a quNode: qreg[] of size n
*	      n: integer (given)
*		  r: integer (given) 
*		  test: qreg[1] 
***************************************************************/ 
module TriangleTestTw(quNode T[R], qreg E[RR1], quNode w, int n, int r, qreg test[1]) 
{
	qreg Ed[R]; 
	qreg tmp[R]	
	int i = 0; 
	int j = 0; 
	int ij = 0; 
	
	ZERO(test);
	
	for(i = 0; i < R; i++)
	{ 
		// Store value into Ed register 
		EdgeORACLE(T[i], w, tmp[i]); 
		CNOT(Ed[i], tmp[i]); 
	}
	
	for(i = 0; i < R; i++)
	{
		for (j = i+1; j < R; j++)
		{	
			ij = i + (j*(j+1))/2; 
			Toffoli(ctrbit[0], Ed[i], Ed[j]); 
			Toffoli(ctrbit[1], ctrbit[0], E[ij]); 
			EvaluateOR(ctrbit[2], ctrbit[1], test[0]); 
			CNOT(ctrbit[3], ctrbit[2]); 
					
			// uncompute 
			InvEvaluateOR(ctrbit[2], ctrbit[1], test[0]);
			Toffoli(ctrbit[1], ctrbit[0], E[ij]); 
			Toffoli(ctrbit[0], Ed[i], Ed[j]); 
					
			ctrONE(test[0], ctrbit[3]); 
					
			// need ancilla here
			ZERO(ctrbit[3]); 
		}
	}
	
	for(i = 0; i < R; i++)
	{
		// Uncompute Ed register
		CNOT(Ed[i], tmp[i]); 
	}
}
 


/**************************************************************
* 	Algorithm 18
*	Para: T: a quNode[R] register
*		  E: qreg[(R(R-1))/2]
*		  w: a quNode: qreg[] of size n
*	      n: integer (given)
*		  r: integer (given) 
		  rbar: integer (given)
*		  GCQWRegs (Graph Collision Workspace Registers)  
*		  quIntr idxIJ[R]  
*		  qreg ctrbit2[n-1]
*		  qreg ctrbit[n-1] 
*	      qreg ctrNode[1]
***************************************************************/ 
module TriangleEdgeSearch(quNode T[R], qreg E[RR1], quNode w, int n, int r, int rbar, GCQWREGS GC, quIntr idxIJ[R],qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1]) 
{
	int i = 0;	
														
	// Grover Search on w using graph collision to T, w													
	for(i = 0; i < n; i++)
	{
		H(w.reg[i]); 
	} 
	
	for(i = 0; i < tg; i++)
	{
		GCQWalk(T,E, w, n,r, rbar, GCQWRegs, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
		
		ZeroRegTest(GC.ctri, ctrbit, CTR); 
		X(ctrbit[CTR-2]); 
		Toffoli(ctrbit[CTR-1], ctrbit[CTR-2], GC.triTestT); 
		CNOT(w.phase[0], ctrbit[CTR-1]); 
		
		// uncompute
		Toffoli(ctrbit[CTR-1], ctrbit[CTR-2], GC.triTestT); 
		X(ctrbit[CTR-2]);
		ZeroRegTest(GC.ctri, ctrbit, CTR);  
			
		//TODO: Assume the inverse function will be present when provided the original circuit 
		InvQCQWalk(T,E, w, n, r, rbar, GC, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 			
		
		// Diffuse on the node
		DIFFUSENode(w, n); 
		
	}	
}
 

/**************************************************************
* 	Algorithm 19
*	Para: T: a quNode[R] register
*		  E: qreg[(R(R-1))/2]
*		  w: a quNode: qreg[] of size n
*	      n: integer (given)
*		  r: integer (given) 
*		  rbar: integer (given)
*		  GCQWRegs (Graph Collision Workspace Registers) 
*		  quIntr idxIJ[R]  
*		  qreg ctrbit2[n-1]
*		  qreg ctrbit[n-1] 
*	      qreg ctrNode[1] 
***************************************************************/ 
module GCQWalk(quNode T[R], qreg E[RR1], quNode w, int n, int r, int rbar, GCQWREGS GC,  quIntr idxIJ[R],qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1]) 
{
	quNode Td; 						
	qreg Ed[R]; 				
	qreg taud[r];
	qreg Ewd;
	qreg Edd[Rbar]; 
	
	int j = 0; 
	int k = 0; 
	
	for(j = 0; j < Rbar ; j++)
	{
		for(k = 0; k < r; k++)
		{
			H((GC.tau[j]).reg[k]); 
		} 
	}  
	
	//Apply Hadamard to Walk Registers
	for(j = 0; j < rbar ; j++)
	{
		H(GC.iota[j]);  
	}  
	
	for(j = 0; j < r ; j++)
	{
		H(GC.sigma[j]);  
	} 
	
	
	// Zero the workspace registers
	for(j = 0; j < n; j++)
	{ZERO(Td.reg[j]); } 
	
	for(j = 0; j < R; j++)
	{ZERO(Ed[j]); }
	
	for(j = 0; j < Rbar; j++) 
	{ZERO(GC.Ew[j]); }
	
	for(j = 0; j < 2*rbar-1; j++)
	{ZERO(GC.cTri[j]); }
	 	
	for(j = 0; j < r; j++)
	{ ZERO(taud); }
	
	ZERO(Ewd); 
	
	for(j = 0; j <Rbar; j++)
	{ ZERO(Edd[j]); }
	
	//Note: In GFI document, it did extra ZERO on the following. It was done earlier already in this procedure. 
	//ZERO(Td, n); 
	//ZERO(Ed, R); 
	
	
	//Set up the walk state
	for(j = 0; j < Rbar; j++)
	{
		FetchT(GC.tau[j], T, Td, r, n, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
		
		// can directly write result into Ew since it is initialized in 0 
		EdgeORACLE(Td, w, GC.Ew[j]); 
		FetchT(GC.tau[j], T, Td, r, n, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	}
	
	for(j=0; j < Rbar; j++)
	{
		FetchE(GC.tau[j], E, Ed, r, ctrbit2, ctrbit, ctrNode[0]); 
		for(k = j+1; k < Rbar; k++)
		{
			FetchTr1(GC.tau[k], Ed, Edd[k], r, 1, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
			
			Toffoli(ctrbit[0], GC.Ew[j], GC.Ew[k]); 
			Toffoil(ctrbit[1], ctrbit[0], Edd[k]); 
			
			ctrCTRincr(GC.cTri, ctrbit[1], ctrbit2, ctrNode[0]); 
			
			// uncompute
			Toffoil(ctrbit[1], ctrbit[0], Edd[k]); 
			Toffoli(ctrbit[0], GC.Ew[j], GC.Ew[k]); 
							
			FetchTr1(GC.tau[k], Ed, Edd[k], r, 1, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
		}	
		FetchE(GC.tau[j], E, Ed, r, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	}
	
	//Execute the Graph Collision Random Walk
	for(j = 0; j < tbarm; j++)
	{
		ZeroRegTest(GC.cTri, ctrbit, CTR); 
		X(ctrbit[CTR-2]); 
		X(GC.triTestT); 
		Toffoli(ctrbit[CTR-1], ctrbit[CTR-2], GC.triTestT); 
		
		//phase flip and the phase bit is always stored at the Rbar_th element's first qubit
		CNOT((GC.tau[Rbar]).reg[0], ctrbit[CTR-1]); 
		
		//uncompute 
		Toffoli(ctrbit[CTR-1], ctrbit[CTR-2], GC.triTestT); 
		X(GC.triTestT); 
		X(ctrbit[CTR-2]);
		ZeroRegTest(GC.cTri, ctrbit, CTR); 
		
		
		for(k = 0; k<tbarw; k++)
		{
			GCQWalkStep(T,E, w, n, r, rbar, GC, Td, Ed, taud, Ewd, Edd, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
		}
	}
}

/**************************************************************
* 	Algorithm 20
*	Para: T: a quNode[R] register
*		  E: qreg[(R(R-1))/2]
*		  w: a quNode: qreg[] of size n
*	      n: integer (given)
*		  r: integer (given) 
*		  rbar: integer (given)
*		  GCQWRegs (Graph Collision Workspace Registers) 
* 		  Td: quNode (that is qreq[n])
*		  Ed: qreg[R]
*		  taud: qreg[r]
*		  Ewd: 	qreg
* 		  Edd:  qreg[Rbar]    
*		  quIntr idxIJ[R]  
*		  qreg ctrbit2[n-1]
*		  qreg ctrbit[n-1] 
*	      qreg ctrNode[1] 
***************************************************************/ 
 
module GCQWalkStep(quNode T[R], qreg E[RR1], quNode w, int n, int r, int rbar, GCQWREGS GC, quNode Td, qreg Ed[R], 
				  qreg taud[r], qreg Ewd[1], qreq Edd[Rbar], quIntr idxIJ[R],qreg ctrbit2[n-1], qreg ctrbit[n-1], qreg ctrNode[1]) 
{
	int j; 
	qreg tmp[1];  
	
	//Perform the Diffuse function on iota and sigma
	// + 1 because we have extra phase bit
	DIFFUSEGC(GC.iota , GC.sigma, rbar+r+1); 		
	
	// Prepare data register for SWAP and Update	
	//Computing taud
	FetchTrbarr(GC.iota, GC.tau, taud, rbar, r, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 	
	
	//Computig Td
	FetchT(taud, T, Td, r, n, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 					
	
	
	FetchStoreT(GC.iota, GC.Ew, Ewd, rbar, 1, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 	
	
	//Computing Ed
	FetchE(taud, E, Ed, r, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 					
	
	// Fetching and computing Edd
	for(j = 0; j < Rbar; j++)					
	{			
		FetchTr1(GC.tau[j], Ed, Edd[j], r, 1, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	}
	
	
	// Update GC.cTri using current edge values in Ewd
	for(j = 0; j < Rbar; j++)					
	{	
		Toffoli(ctrbit[0], Ewd, GC.Ew[j]); 
		Toffoli(ctrbit[1], ctrbit[0], Edd[j]); 
		
		ctrCTRdecr(GC.cTRi, ctrbit[1], ctrbit2, ctrNode[0]); 
		
		//uncompute 
		Toffoli(ctrbit[1], ctrbit[0], Edd[j]); 
		Toffoli(ctrbit[0], Ewd, GC.Ew[j]);
	}
	
	
	// Erase current edge values in Ewd 
	EdgeORACLE(Td, w, tmp[0]);
	CNOT(Ewd, tmp[0]); 
	
	// Prepare data register for SWAP
	for(j = 0; j < Rbar; j++)					
	{	// Uncompute Edd
		FetchTr1(GC.tau[j], Ed, Edd[j], r, 1, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	}
	
	FetchE(taud, E, Ed, r, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 					// Uncompute Ed
	
	FetchT(taud, T, Td, r, n, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 					// Uncompute Td
	
	StoreTrbarr(GC.iota, GC.tau, taud, rbar, r, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 	
	
	
	for(j = 0; j < r; j++)
	{
		Swap(taud[j], GC.sigma[j]); 
	}
	
	// Uncompute data registers after SWAP operation
	StoreTrbarr(GC.iota, GC.tau, taud, rbar, r, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	
	FetchT(taud, T, Td, r, n, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	
	FetchE(taud, E, Ed, r, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	
	for(j = 0; j < Rbar; j++)
	{
		FetchTr1(GC.tau[j], Ed, Edd[j], r, 1, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	}
	
	// Compute new edge info in Ewd
	// Can directly call tmp[0] as Oracle writes the right value despite of the initial value of tmp[0]
	EdgeORACLE(Td,w, tmp[0]); 
	CNOT(Ewd, tmp[0]); 
	
	// Update Ewd and GC.cTri using  any new triangles involving Ewd
	for(j = 0; j < Rbar; j++)
	{
		Toffoli(ctrbit[0], Ewd, GC.Ew[j]); 
		Toffoli(ctrbit[1], ctrbit[0], Edd[j]); 
		
		ctrCTRdecr(GC.cTRi, ctrbit[1], ctrbit2, ctrNode[0]); 
		
		//uncompute 
		Toffoli(ctrbit[1], ctrbit[0], Edd[j]); 
		Toffoli(ctrbit[0], Ewd, GC.Ew[j]);
	}
	
	// Restore data and data registers to initial state
	for(j  = 0; j < Rbar; j++)
	{
		FetchTr1(GC.tau[j], Ed, Edd[j], r, 1, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	}
	
	
	// Could use ZERO as this step is to set Ed to 0 
	FetchE(taud, E, Ed, r, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 						
	FetchStoreT(GC.iota, Ew, Ewd, rbar, 1, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 
	
	// Could use ZERO as this step is to set Td to 0 
	FetchT(taud, T, Td, r, n, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 		
	
	// Could use ZERO as this step is to set taud to 0				
	FetchTrbarr(GC.iota, GC.tau, taud, rbar, r, idxIJ, ctrbit2, ctrbit, ctrNode[0]); 	
}	
 
/**************************************************************
* 	Algorithm Testing for Main
***************************************************************/ 
module main()
{
	int i;
	int b=4;	
	int j;
			
    QWTFP(15,9); 

}





