/****************************************************************************************
*
* SVP.quantum
*
* Oana Theogarajan, UCSB
*
* 
* Implements the SVP GFI 
*
* December 2011
*
*****************************************************************************************/
gate zprepare(qreg q, int state);
gate zmeasure(qreg q, creg result);
gate H(qreg q);
gate Z(qreg q);
gate S(qreg q);
gate Rz(qreg target, double theta); 
gate CNOT(qreg target,qreg control);


#define PI 3.14159
#define n 50 //size of integer lattice
#define dim 4*pow(n,2)+1+n //dimension of quantum state =10 051
#define kmax 4*pow(n,2)+n //number of quantum states used =10 050
//there's an inconsistency in the GFI - on page 11 kmax is 4n^2+4n , but in the implementation of TPP and DCP it's 4n^2+n
//I think it's the latter - use that for now
#define maxp log(2,2*n*n*n)//number qubits needed to store p or m =18
#define dim_b 4*n //number of qubits needed to store elements of Bbar and a = 200
#define dim_cc 4*pow(n,2)+1 //dimension of the function used in coherent compute - stores t and a_1....a_n
const char Bfile="Bfile.txt"; //file containing integer lattice


/* GFI-IARPA - this corresponds to Algorithm 1 - uSVP,just rephrased as main and considering B as a global variable*/
//the main module is classical and calls Q a number of times - all the quantum part is in Q 
void module main()
{
	int i,j,m,i0;
	int p; //smallest prime between n^3 and 2n^3
	int l;
	int<4*n> B[n][n];  //not clear how big B can get - not specified in GFI,
	// but since the a_i are up to 2^(4n)=2^(200) we assumed B elements are of teh same order of magnitude/need the same number of qubits 
	// that means they need 200 bits so not really able to be stored as ints or longs or anything else...we will have a user-defined size int
	int<4*n> Bbar[n][n];
	int ubar[n];
	
	
	//read matrix B from file into array B
	forall(i=0; i < n; i++)
	{
		forall(j=0; j < n; j++) 
		{
			B[i,j]=ReadLine(Bfile,Index2to1Dimension(i,j)); //to do - don't have I/O functions yet
		}
	}
	
	//classical functions finding the smallest prime between two numbers n and 2n
	//to do - implement the classical algorithm presented in http;//classic-web.archive.org/web/20050716082540/www.cse.iitk.ac.in/news/primality.html
	p=SmallestPrime(pow(n,3),2*pow(n,3)); //to do - don't have a way to define the pow function yet
	
	//classical function implementing the LLL algorithm 
	//to do - implement using A. K. Lenstra, H. W. Lenstra, Jr., and L. Lov´asz. Factoring polynomials with rational coefficients.Mathematische Annalen, 261(4):515–534, Dec. 1982.
	LLL(B,Bbar); //transforms B into Bbar 
	
	//initialize l with the ceil of norm of bbar_1 (first column of Bbar)
	l=ceil(Bbar,NormColumn(i)); //to do - ceil function
	
	forall(j = 1;j<=ceil*((n-1)/2);j++) //25
		{
		forall(m = 1;m<=(p-1);m++) //2*n^3 = 250 000
			{
			forall(i0=1;i0<=n;i0++) //50 
				{//this could be called 25*250000*50=3.125*10^8 times 
				
				//call module Q implementing Algorithm 2 from the GFI
				//Q - and algorithms it calls - is the only quantum part
				Q(Bbar,n,l,m,i0,p,ubar);
				
				//in Q we have a bunch of measurements, which lead to a ubar classical array 
				//we then need to perform classical tests on it and based on that apply Q again or not
				if((Norm(ubar)<pow(n,3))&&(BelongsToLattice(ubar)))
					{
					printf("ubar:\n");
					forall(i=0;i<n;i++)
						{
						printf("%d \t",ubar[i]); //to do - need I/O functions
						}
					//stop the program, ubar is the result we wanted
					exit; 
					}
				}
			}
			l=l/2;
		}
	printf("Algorithm failed"); //to do - need I/O functions
}

/* GFI-IARPA - Algorithm 2*/
//has to return an array - ubar=Bbar*u
void module Q(int Bbar[n][n],int n, int l, int m, int i0, int p, int ubar[n])
{
	int k;
	int i,j;
	int u[n];
	
	//need to declare 4n^2+n quantum registers, each of dimension dim=4n^2+1 to hold the psi functions
	//best way I can think of is if we define quantum registers like classical arrays, allowing for multiple dimensions - to do 
	//each row represents a quantum state psi_k from the GFI
	//during the algoruthm we create ancilla bits and the state psi will have 4n^2+1+n qubits - make this the dimension of q
	qreg q[kmax][dim];
	
	forall(k=0;k<kmax;k++) //10 050
		{
		//In the GFI, we have to return a quantum register from R and assign it to a row in our multi-dimensional qreg q
		// We can change that slightly and get R to modify the respective row in the multidimensional qreg q
		//q passed by reference
		R(Bbar,q,n,l,m,i0,p,k); //R called 10 050 times
		}
	
	TPP(n,q,u);
	u[i0]=u[i0]*p+m;
	
	//set ubar to product Bbar*u
	for (i=0;i<n;i++)
		{
		ubar[i]=0;
		forall(j=0;j<n;j++)
			{
			ubar[i]=ubar[i]+Bbar[i][j]*u[j];
			}
		}
}

/* GFI-IARPA Algorithm 3 */
void module R(int Bbar[n][n],qreg q[kmax][dim], int n, int l, int m, int i0, int p, int k)
{
	double w[n];
	int Bmax;
	int i;	
	const int Nancilla=5*n*n+n*ceil(log(2,Bmax));
	//we need another quantum register of length 5n^2 +log_2(Bmax) for the ancilla qubits needed for the output of CoherentCompute
	qreg ancilla[Nancilla];
	creg z;
	qreg regB[n][n][dim_b]; //used to represent Bbar on qubits before passing to c2qg for reversible computation
	qreg regm[maxp]; //used to prepare m on qubits
	qreg regp[maxp];
	qreg regl[dim_b];
	qreg regW[n][dim_b];
	
	for (i=0;i<n;i++)
	{	
		w[i]=rnd(); //generate a random number between 0 and 1
	}
	
	//set Bmax to highest value in Bbar
	Bmax=MaxBbar();
	
	//prepare + states in the 4n^2+1 registers we reserved for psi in q[k]
	//there are 4n^2+1 because we have n components of a, each can have a value up to 2^(4n)-1=> needs 4n qubits, and 1 qubit needed for t 
	// - see Definition3,4,5 and Lemma 1 on page 7 of GFI
	for (i=0;i<(4*n*n+1);i++) //10 001
	{
		zprepare(q[k][i],0);
		H(q[k][i]);
	}
	
	//prepare ancilla as 0
	for (i=0;i<Nancilla;i++) //5n^2+n*ceil(log(2,Bmax))=5n^2+n*4n=22 500 (assuming maximum value for Bmax=2^4n)
	{
		zprepare(ancilla[i],0);
	}
	
	//Coherent compute g composed with f - using reversible logic for adders,multipliers 
	//t is first qubit in q, next n are a1 , next n a2 etc... 
	//store results in ancilla
	
	prepareB(Bbar,regB); //4n^3=500 000 zprepare
	prepareInt(m,regm); //log_2{2n^3}=18 zprepare
	prepareInt(p,regp); //log_2{2n^3}=18 zprepare
	preparel(l,regl); //4n=200 zprepare
	prepareW(w,regW); //4n^2=10 000 zprepare
	//i0 is a purely classical parameter, for each different i0 the reversible logic synthetizer will generate a different circuit
	CoherentComputeGF(q[0], q[1..dim_cc-1], regm, regp, i0, regB,regl, regW, ancilla[Nancilla]);
	
	//measure ancilla qubits 
	// we don't care about the result - ancilla qubits will be garbage after measurement
	for (i=0;i<Nancilla;i++) //5n^2+n*ceil(log(2,Bmax))=5n^2+n*4n=22 500
	{
		zmeasure(ancilla[i],z);
	}
	//we have now qubits in q[k][0.....4n^2] storing the quantum state psi we need in Q	
}



/* GFI-IARPA Algorithm 4 */
void module TPP(int n, qreg q[kmax][dim], int u[n])
{
	int i,j;
	int<n> M,d;
	
	
	//for each psi we'll need n qubits to store the result of CoherentCompute - the result is an integer < 2^(4n^2+n) and we only have 
	// 4n^2+1 qubits - so we need n more ancilla qubits
	// the first qubit of psi will not be involved in the CoherentCompute
	
	
	//for each psi_k prepare ancilla and Apply CoherentCompute 
	for (i=0;i<(4*n*n+n);i++) //10 050
	{
		for (j=0;j<n;j++) //50
		{
			//the ancilla qubits are stored in q in the qubits from 4n^2+1 on 
			zprepare(q[i][4*n*n+1+j],0); //502 500
		}
		
		// Leave first qubit alone (will correspond to t) and Coherent Compute h on the next 4n^2+n qubits
		// The first 4n^2 represent vector a, the output will be stored in all 4n^2+n qubits
		
		CoherentComputeH(q[i][1..dim_cc-1],q[i][1..dim-1]);	
		//the new quantum state is stored back in q and has 4n^2+n+1 qubits - I'll call it "extended psi"
	}
	
	//call DCP with input all the extended psis and N=2^(4n^2+n) - returns a positive integer d
	d=DCP(n,0,0,q);
		
	M=pow(2,4*n); //map d into a n-dimensional vector u
		
	//add d to number MMMMMMMM..M in base 2M (i.e. M*(2M)^(n-1)+...+M*(2M)^0)
	d=d+(M-M*pow(2*M,n))/(1-2*M);
	
	//set u elements to the digits of d in base 2*M and subtract the added MMMMMMMMM
	for	(i=0;i<n;i++)
	{
		u[i]=d/pow(2*M,n-i-1)-M; //integer division
		d=d-d%pow(2*M,n-i-1); //set d to the remainder of the division
	}
	//our "modules" will have to be more like functions and be able to return pointers
	
}


/* GFI-IARPA Algorithm 5 */
/* this algorithm is in the process of geing revised by Travis Humble, there are major unclear points and problems in the original GFI */
/* This is a preliminary version implemented by Aram Harow.
 In order to make the algorithm logically consistent, it makes some changes that Travis is aware of and is considering while re-writing.
 Bottom line - this is not exactly the GFI, the GFI will be changed, and this is preliminary */
 
//has to return an integer d
//in GFI - N is passed as an argument, N is 2^n (? as far as I understand at this point) and then do n=log_2(N)  
//I'll pass n as an argument assuming the above is true 

//If the compiler cannot return an int of arbitrary size, we can easily change this alogirthm
//In algorithm 4, change d=DCP(n,0,0,q) to DCP(n,0,0,q,d) and change the input and return (to void) paramters in the following function accordingly
//Then delete the two instances of return (leave what comes after, just delete those words) and change the last if statment to have d=dlow rather than just dlow
int<n> module DCP(int n,int<n> dlow,int s,qreg psi_in[kmax][n+1])
{
	int n_inputs=(n-s)*n;	
	creg z[n_inputs][n];
	int<n> z_sort[n_inputs]; //each z[i] is a n=50 bit integer - use the user-defined size int type
	creg z_meas;
	int n_merged = 0;
	int n_qubits;
	creg d_lsb;

	forall(int i = 0; i< n_inputs; i++){
		QFT(psi_in[i][1..n]); //remember indices are 0 - based 
		z_sort[i]=0;
		for (int j = 0; j < n; j++){
			zmeasure(psi_in[i][j+1],z[i][j]);
			z_sort[i]=z_sort[i] << 1 +(int)z[i][j]; //z[i][0] is the most significant bit
			}
		//we're left with psi_in[i][0] as the states 	
		Rz(psi_in[i][0],-2*PI*dlow/pow(2,n)); //I'm assuming the i in -2 PI i dlow/N in the GFI is a typo you would apply e^{-2 Pi i dlow/N}
												//but the rotation angle is without the i
	}

	int m = ceil(sqrt(n-s-1));
	n_qubits=n_inputs;
	
	forall(int j = 0; j< m; j++) {
	
		quicksort(z_sort,psi_in[0..n*n-1][0],0,n_qubits-1); //only need n_qubits but declare the qreg of size n^2 (qregs are static size)
		
		forall(int i = 0; i< (n_qubits-1); i++) {
			
			//compare bits n-m*(j+1)+1 through n-m*j of z_sort[i] and z_sort[i+1]
			int<n> mask=(1 << (m*(j+1))-1) ^ ((1 << m*j)-1); 
			if ((z[i] & mask) == (z[i+1] & mask)){
				CNOT(psi_in[i+1][0],psi_in[i][0]);
				zmeasure(psi_in[i+1],z_meas);
				if(z_meas==1){
					//keep quantum state psi_i in the set 
					if(i>n_merged){
						//swap functions such that we store the functions we keep in the first qreg slots <n_merged 
						Swap(psi_in[i],psi_in[n_merged]);  
						}
					z_sort[n_merged]=z_sort[i+1]-z_sort[i];
					n_merged++;
				}
			}
		}
		n_qubits = n_merged;
	}
	
	//look for a z_sort[i]=2^(n-s)
	int flag=0;
	forall(int i=0;i<n_merged;i++){
		if(z_sort[i]==pow(2,(n-s))){
			flag=1;
			H(psi_in[i]);
			zmeasure(psi_in[i],d_lsb);
			dlow=dlow+pow(2,(n-s))*(int)d_lsb;
			return DCP(n,dlow,s+1,qreg psi_in[kmax][n+1]);
		}
	}
	if(flag==0){
		return dlow;
	}
}

//Helper functions 


//classical function calculating the index in the one dimensional array corresponding to a i,j pair 
//to do - don't have classical functions now
int Index2to1Dimension(int i, int j)
{
int tmp;
int idx;
if (i<j)
	{
	tmp=i;
	i=j;
	j=tmp;
	}
idx=i*(i+1)/2+j;
return idx;
}


//calculate norm of a column of Bbar matrix
double NormColumn(int Bbar[n][n], int i)
{
int k;
double norm=0;
for (k=0;k<n;k++)
	{
	norm = norm + pow(Bbar[k][i],2); //to do - pow function
	}
norm = sqrt(norm); //to do - sqrt function
return norm;
}


//WE NEED a way to pass arrays as parameters - we need the norm of an arbitrary vector to test if ubar is the vector we want
//calculate norm of vector - assume size is n
double Norm(int vector[n])
{
int k;
double norm=0;
for (k=0;k<n;k++)
	{
	norm = norm + pow(vector[k],2); //to do - pow function
	}
norm = sqrt(norm); //to do - sqrt function
return norm;
}


//classical function implementing the LLL algorithm 
//to do - implement using A. K. Lenstra, H. W. Lenstra, Jr., and L. Lov´asz. Factoring polynomials with rational coefficients.Mathematische Annalen, 261(4):515–534, Dec. 1982.
int* LLL(int B[n][n],int Bbar[n][n]) //transforms B into Bbar - use global arrays rather than passing huge arrays
{
int* Bbarptr;
Bbarptr=Bbar;
//code from algorithm mentioned above ....
return Bbarptr;
}

//test if vector is in the lattice
//return 0 if false, 1 if true
int BelongsToLattice(int vector[n])
{

}

//return max value of matrix Bbar
int MaxBbar(int Bbar[n][n])
{
int i,j;
int max=-99999999;
for (i=0;i<n;i++)
	{
	for (j=0;j<n;j++)
		{
		if(Bbar[i][j]>max)
			{
			max=Bbar[i][j];
			}
		}
	}
return max;
}

// Swaps 2 qubit states
// Takes as input the 2 qubits
void module Swap(qreg q1,qreg q2)
{
	CNOT(q2,q1);
	CNOT(q1,q2);
	CNOT(q2,q1);
}

// Implements a controlled rotation
// inputs are the target qubit, control qubit and the rotation angle
void module ControlledRotation(qreg target, qreg control, double theta)   
{
	Rz(target, theta / 2.0);
	CNOT(target, control);
	Rz(target, -1.0 * theta / 2.0);
	CNOT(target, control);
}
// Controlled version of gate [1 0; 0 e^(i*PI/2^k)] - the R gate appearing in the quantum Fourier transform
// parameters are the target qubit, control qubit and the integer k from 2^k
void module ControlledRotationPi(qreg target, qreg control,int j)
{
	ControlledRotation(target, control,PI/pow(2,j));
}



void module QFT(qreg reg[n]) //n*(n-1)/2 *(3Rz + 2 CNOT)
{
	int i,j;	
	for (i=0;i<n;i++)
    	{
		H(reg[i]);
		for (j=1;j<(n-i);j++)
			{
			ControlledRotationPi(reg[i+j],reg[i],j);
			}
    	}
	for (i=0;i<(n/2);i++)
    	{
		Swap(reg[i],reg[n-1-i]);
		}
}

void module quicksort(int<n> z_sort[n*n], qreg psi[n*n], int start,int stop){
	if(stop > start){
		int pivot_index=start;
		int lh=start+1;
		int rh=stop;
		int<n> pivot=z_sort[start];
		while(true){
			while(lh<rh && z_sort[rh]>=pivot)
				rh--;
			while(lh<rh && z_sort[lh]<pivot)
				lh++;
			if(lh==rh)
				break;
			//swap z_sort and the corersponding psi's
			int<n> tmp=z_sort[lh];
			z_sort[lh]=z_sort[rh];
			z_sort[rh]=tmp;
			Swap(psi[lh],psi[rh]); 
		}
		if(z_sort[lh]<pivot){
			//swap z_sort[start](original pivot) with z_sort[lh]
			tmp=z_sort[start];
			z_sort[start]=z_sort[lh];
			z_sort[lh]=tmp;
			Swap(psi[start],psi[lh]);
			//the pivot is now in the lh position so pivot_index=lh
			pivot_index=lh; 	
		}
		//recursively call quicksort on the 2 parts of teh array
		quicksort(z_sort,psi,start,pivot_index-1);
		quicksort(z_sort,psi,pivot_index+1,stop);
	}
}

//prepare state to pass to c2qg module		
void module prepareB(int Bbar[n][n], qreg regB[dim_b]){
	//loop over each element of Bbar, and loop on each bit and set the corresponding qubit
	//n*n elem * 4n zprepare => 500 000 zprep
	int i,j,k;
	int mask=1;
	forall(i=0;i<n;i++){
		forall(j=0;j<n;j++){
			forall(k=0;k<dim_b;k++){
				if(Bbar[i][j] & mask){
					zprepare(regB[i][j][dim_b-1-k],1); 
					//we use dim_b-1-k so that the last qubit in the array is the least significant bit
				 } 
				 else{
					zprepare(regB[i][j][dim_b-1-k],0);
				}
				mask=mask << 1;
			}
		}
	}
}

void module prepareW(double w[n], qreg regW[dim_b]){
	//w_i is between 0 and 1
	//loop over each element and set corresponding qubits 
	//n elem * 4n zprepare => 10 000 zprep
	int i,k;
	int mask=1;
	forall(i=0;i<n;i++){
		forall(k=0;k<dim_b;k++){
			if(w[i]/(1/pow(2,mask))>1){
				zprepare(regW[i][k],1);
			} 
			else{
				zprepare(regW[i][k],0);
			}
			mask=mask+1;
		}
	}
}


//prepare m or p - of size maxp //maxp=log_2{2n^3}=18 zprep
void module prepareInt(int number, qreg regInt[maxp]){
	int i;
	int mask=1;
	forall(i=0;i<maxp;i++){
		if(number & mask){
			zprepare(regInt[i],1);
		}else{
			zprepare(regInt[i],0);
		}
		mask=mask << 1;
	}
}


//need a different module for preparing l since the qreg parameter has different size
//the language requires the size of the quantum registers used as parameters to be a constant 
void module preparel(int number, qreg regInt[dim_b]){ //dim_b=4n=200 zprepare
	int i;
	int mask=1;
	forall(i=0;i<dim_b;i++){
		if(number & mask){
			zprepare(regInt[i],1);
		}else{
			zprepare(regInt[i],0);
		}
		mask=mask << 1;
	}
}


//v is the result - is an integer vector of size n=50 
void c2qg CoherentComputeF(int<1> t, int<dim_b> a[n], int<maxp> m, int<maxp> p, int i0, int bbar<4*n>[n][n], int<dim_b> v[n]){
	for (int j=0;j<n;j++){
		v[j]=(a[i0]*p+t*m)*bbar[i0][j];
		for (int i=0;i<n;i++){
			if(i!=i0){
					v[j]=v[j]+a[i]*bbar[i][j];
			}
		}
	}
	
}	


//size in qbits for each elem in g is ceil(log_2(Bmax))+5*n Bmax is a given constant <2^4n and n=50
void c2qg CoherentComputeG(int<dim_b> v[n],int<dim_b> l, double<dim_b> w[n],double<dim_b> g[n]){
	g[j]=floor(v[j]/(128*l)-w[j]);
}

void CoherentComputeGF(int<1> t, int<dim_b> a[n], int<maxp> m, int<maxp> p, int i0, int<dim_b> bbar[n][n],int<dim_b> l, double<dim_b> w[n],double<dim_b> g[n]){
	int<dim_b> v[n];
	CoherentComputeF(t,a,m,p,i0,bbar,v);
	CoherentComputeG(v,l,w,g);
}

void c2qg CoherentComputeH(int<dim_b> a[n],int<kmax> h){
	//use a CS style index notation - starting from 0 to n-1 for a (in GFI is 1 to n) 
	h=a[0];
	forall(int i=1;i<n;i++){
		h=h+pow(2,(4*n+1)*i);
	}
}



